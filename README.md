# nesfr3_node_description
'Description of cartographer_node, cartographer_occupancy_grid_node, and nesfr3_tracking'
This will concretely explain the roles, and the topics that comes in and goes out.

## 1. Cartographer_node
Cartographer_node and Cartographer_occupancy_grid_node are the Google open source libraries. Cartographer is a system that provides real-time SLAM in 2D and 3D across multiple platforms and sensor configurations. Anyone can approach to its sources through [cartographer](https://github.com/cartographer-project/cartographer, "ROS_Wiki").  

### 1.1. package
Cartographer_node is included in the 'cartographer_ros' package.

### 1.2. Role
The cartographer_node is the SLAM node used for online, real-time SLAM.
Using lidar data, it generates submaps and passes to the occupancy_grid_node.    

### 1.3. Topics
* Subscribes
```
- nesfr3/1/lidar/points
- nesfr3/1/wheel_odom
- nesfr3/1/lidar_imu
```
```nesfr3/1/lidar/points``` is just ```sensor_msgs/PointCloud2``` type message, which contains the lidar points data.   
```nesfr3/1/wheel_odom``` is ```nav_msgs/Odometry``` type message. It would be generated by the encoder located in the wheel we guess.
```nesfr3/1/lidar_imu``` is just ```sensor_msgs/Imu``` type message. We don't know the reason why they changed the name of the topic as lidar_imu.    
It is not clear that whether the nesfr3 robot has the imu sensor itself or not.

* Publishes
```
- nesfr3/1/submap_list
```
```nesfr3/1/submap_list``` is the submap_list topic. Each step, cartograhper will create its own local map. And they save those local maps in this submap_lists and send to the cartographer_occupancy_grid_node. 

* * *
reference : [ROS API reference documentation](https://google-cartographer-ros.readthedocs.io/en/latest/ros_api.html, "google_cartographer")

## 2. Cartographer_occupancy_grid_node
### 2.1. package
Cartographer_occupancy_grid_node is included in the 'cartographer_ros' package.

### 2.2. Role
By receiving the submap_lists through the ```nesfr3/1/submap_list``` topic, this node will generate the global map. 
<img src = "/Shots/cartograhper1.png"></img>
As you can see from the above image, the global map is not generated accurately, due to poor loop closure. 

### 2.3. Topics
* Subscribes
```
- nesfr3/1/submap_list
```

* Publishes
```
- nesfr3/1/map
```
```nesfr3/1/map``` is ```nav_msgs/OccupancyGrid``` type. We can visualize the SLAM in RViz by adding the topic name ```nesfr3/1/map```. 
* * *
reference : [ROS API reference documentation](https://google-cartographer-ros.readthedocs.io/en/latest/ros_api.html, "google_cartographer")

## 3. nesfr3_tracking
nesfr3_tracking node is for **matching process**. There are several function defined in this ```nesfr3_human_matching.py```. Considering these functions, we can define that the two main job for this node are
```
1. Matching cbox and bbox.
2. Matching hsv histogram and the actor id.
```
### 3.1. package
nesfr3_tracking node is included in the 'nesfr3_tracking' package. 

### 3.2. Role
The main 4 functions defined in this node are ```onImage(data_bbox, data_cbox, data_cluster)```, ```scoring(cluster_spec, bbox_spec)```, ``` hist_callback(data_img, data_hist, data_state, data_id)``` and ```state_callback(data_img, data_hist, data_state)```.
Starting from ```onImage()``` function we will discuss about the role of this node.

* onImage(data_bbox, data_cbox, data_cluster)
    - Main role of this function is to comparing the cluster box specification and the boundary box specification to identify whether those two boxes are corresponds to the same person. 
    - Through this process, we can filter out the rest of bboxes except for the human. The method for deciding correspondence comes from the following function ```scoring(cluster_spec, bbox_spec)```. 
    
* scoring(cluster_spec, bbox_spec)
    - If the two boxes(cbox, bbox) show the same cluster(human), then the boxes drawn should have the same dimension in x direction. It is x direction because one image came from the fisheye camera are shown in 2D, while the lidar point cloud data has 3D information. 
    - By comparing the x dimension width between each boxes, we could measure the ```x_score``` value through some simple steps. With the high ```x_score``` value was returned, than it shows the high correspondence. 
    
* hist_callback(data_img, data_hist, data_state, data_id)
    - The above two functions were about the boxes, but now it is about the human_id. ```hist_callback()``` function measures the HSV histogram vaule of each image and then make it save in its own repository list(```hist_list```). 
    - Simply, the size of the list was 10. So if the number of the income HSV histogram's value data is over than 10, the first data in the array would be poped out, so the size of the array is maintained with 10. 
    - Like this, everytime 10 hist value will be used in next function, make sure that whether the human was already detected or not.
    
* state_callback(data_img, data_hist, data_state)
    - It compares the current histogram value data with the previous saved 10 data. 
    - It also use 'scoring' method but this scoring is not the same with the above method. Whether the histogram value data was not in the ```hist_list``` data in the above function, than the nesfr3 identifiest the human with ```new_id```.
    
* * *
reference : [wom-ai/Point Cloud 3d Clustering](https://github.com/wom-ai/nesfr3_workspace/wiki/Point-Cloud-3d-Clustering, "nesfr3_tracking")

